// Generated by CoffeeScript 1.3.1
(function() {
  var Segment, arraySubclass, divideLength, facet, facetArrayPrototype, flatten, makeFacetArray, stripeTile;

  arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
    return array;
  } : function(array, prototype) {
    var property, _i, _len;
    for (_i = 0, _len = prototype.length; _i < _len; _i++) {
      property = prototype[_i];
      array[property] = prototype[property];
    }
    return array;
  };

  flatten = function(ar) {
    return Array.prototype.concat.apply([], ar);
  };

  Segment = (function() {

    Segment.name = 'Segment';

    function Segment(_arg) {
      var stage;
      this.parent = _arg.parent, this.data = _arg.data, this.node = _arg.node, stage = _arg.stage, this.prop = _arg.prop;
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack = [stage];
    }

    Segment.prototype.getStage = function() {
      return this._stageStack[this._stageStack.length - 1];
    };

    Segment.prototype.setStage = function(stage) {
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack[this._stageStack.length - 1] = stage;
    };

    Segment.prototype.pushStage = function(stage) {
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack.push(stage);
    };

    Segment.prototype.popStage = function() {
      if (this._stageStack.length < 2) {
        throw "must have at least one stage";
      }
      this._stageStack.pop();
    };

    return Segment;

  })();

  window.facet = facet = {};

  facet.split = {
    natural: function(attribute) {
      return function(d) {
        return d[attribute];
      };
    },
    bucket: function(attribute, size, offset) {
      return function(d) {
        var b;
        b = Math.floor((d[attribute] + offset) / size) * size;
        return "" + b + ";" + (b + size);
      };
    },
    time: {
      second: function(attribute) {
        return function(d) {
          var de, ds;
          ds = new Date(d[attribute]);
          ds.setUTCMilliseconds(0);
          de = new Date(ds);
          de.setUTCMilliseconds(1000);
          return [ds, de];
        };
      },
      minute: function(attribute) {
        return function(d) {
          var de, ds;
          ds = new Date(d[attribute]);
          ds.setUTCSeconds(0, 0);
          de = new Date(ds);
          de.setUTCSeconds(60);
          return [ds, de];
        };
      },
      hour: function(attribute) {
        return function(d) {
          var de, ds;
          ds = new Date(d[attribute]);
          ds.setUTCMinutes(0, 0, 0);
          de = new Date(ds);
          de.setUTCMinutes(60);
          return [ds, de];
        };
      },
      day: function(attribute) {
        return function(d) {
          var de, ds;
          ds = new Date(d[attribute]);
          ds.setUTCHours(0, 0, 0, 0);
          de = new Date(ds);
          de.setUTCHours(24);
          return [ds, de];
        };
      }
    }
  };

  facet.apply = {
    count: function() {
      return function(ds) {
        return ds.length;
      };
    },
    sum: function(attribute) {
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        });
      };
    },
    average: function(attribute) {
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        }) / ds.length;
      };
    },
    min: function(attribute) {
      return function(ds) {
        return d3.min(ds, function(d) {
          return d[attribute];
        });
      };
    },
    max: function(attribute) {
      return function(ds) {
        return d3.max(ds, function(d) {
          return d[attribute];
        });
      };
    },
    unique: function(attribute) {
      return function(ds) {
        var count, d, seen, v, _i, _len;
        seen = {};
        count = 0;
        for (_i = 0, _len = ds.length; _i < _len; _i++) {
          d = ds[_i];
          v = d[attribute];
          if (!seen[v]) {
            count++;
            seen[v] = 1;
          }
        }
        return count;
      };
    }
  };

  facet.prop = function(propName) {
    return function(segment) {
      return segment.prop[propName];
    };
  };

  divideLength = function(length, sizes) {
    var lengthPerSize, size, totalSize, _i, _len;
    totalSize = 0;
    for (_i = 0, _len = sizes.length; _i < _len; _i++) {
      size = sizes[_i];
      totalSize += size;
    }
    lengthPerSize = length / totalSize;
    return sizes.map(function(size) {
      return size * lengthPerSize;
    });
  };

  stripeTile = function(dim1, dim2) {
    var makeTransform;
    makeTransform = function(dim, value) {
      if (dim === 'width') {
        return "translate(" + value + ",0)";
      } else {
        return "translate(0," + value + ")";
      }
    };
    return function(_arg) {
      var gap, size, _ref;
      _ref = _arg != null ? _arg : {}, gap = _ref.gap, size = _ref.size;
      return function(parentSegment, segmentGroup) {
        var availableDim1, curDim1, dim1s, dimSoFar, i, maxGap, n, parentDim1, parentDim2, parentStage, segment, segmentStage, _i, _len;
        gap || (gap = 0);
        size || (size = function() {
          return 1;
        });
        n = segmentGroup.length;
        parentStage = parentSegment.getStage();
        if (parentStage.type !== 'rectangle') {
          throw new Error("Must have a rectangular stage (is " + parentStage.type + ")");
        }
        parentDim1 = parentStage[dim1];
        parentDim2 = parentStage[dim2];
        maxGap = Math.max(0, (parentDim1 - n * 2) / (n - 1));
        gap = Math.min(gap, maxGap);
        availableDim1 = parentDim1 - gap * (n - 1);
        dim1s = divideLength(availableDim1, segmentGroup.map(size));
        dimSoFar = 0;
        for (i = _i = 0, _len = segmentGroup.length; _i < _len; i = ++_i) {
          segment = segmentGroup[i];
          curDim1 = dim1s[i];
          segmentStage = {
            type: 'rectangle'
          };
          segmentStage[dim1] = curDim1;
          segmentStage[dim2] = parentDim2;
          segment.setStage(segmentStage);
          segment.node.attr('transform', makeTransform(dim1, dimSoFar)).attr(dim1, curDim1).attr(dim2, parentDim2);
          dimSoFar += curDim1 + gap;
        }
      };
    };
  };

  facet.layout = {
    overlap: function() {
      return {};
    },
    horizontal: stripeTile('width', 'height'),
    vertical: stripeTile('height', 'width'),
    tile: function() {}
  };

  facet.stage = {
    rectToPoint: function(xPos, yPos) {
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'rectangle') {
          throw new Error("Must have a rectangle stage (is " + stage.type + ")");
        }
        segment.pushStage({
          type: 'point',
          x: xPos * stage.width,
          y: yPos * stage.height
        });
      };
    }
  };

  facet.plot = {
    rect: function(_arg) {
      var color;
      color = _arg.color;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'rectangle') {
          throw new Error("Must have a rectangle stage (is " + stage.type + ")");
        }
        segment.node.append('rect').datum(segment).attr('width', stage.width).attr('height', stage.height).style('fill', color).style('stroke', 'black');
      };
    },
    text: function(_arg) {
      var color, text;
      color = _arg.color, text = _arg.text;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'point') {
          throw new Error("Must have a point stage (is " + stage.type + ")");
        }
        segment.node.append('text').datum(segment).attr('x', stage.x).attr('y', stage.y).attr('dy', '.71em').style('fill', color).text(text);
      };
    },
    circle: function(_arg) {
      var color;
      color = _arg.color;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'point') {
          throw new Error("Must have a point stage (is " + stage.type + ")");
        }
        segment.node.append('text').datum(segment).attr('cx', stage.x).attr('cy', stage.y).attr('dy', '.71em').style('fill', color).text(text);
      };
    }
  };

  facet.sort = {
    natural: function(attribute, direction) {
      var cmpFn;
      if (direction == null) {
        direction = 'ASC';
      }
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(a.prop[attribute], b.prop[attribute]);
      };
    },
    caseInsensetive: function() {
      var cmpFn, direction;
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(String(a.prop[attribute]).toLowerCase(), String(b.prop[attribute]).toLowerCase());
      };
    }
  };

  facetArrayPrototype = [];

  facetArrayPrototype._eachSegment = function(fn) {
    var segment, segmentGroup, _i, _j, _len, _len1;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      segmentGroup = this[_i];
      for (_j = 0, _len1 = segmentGroup.length; _j < _len1; _j++) {
        segment = segmentGroup[_j];
        fn(segment);
      }
    }
  };

  facetArrayPrototype.split = function(name, split) {
    var segmentGroup;
    if (typeof split !== 'function') {
      throw new TypeError("Split must be a function");
    }
    segmentGroup = flatten(this).map(function(f) {
      var bucket, bucketValue, d, key, keys, _i, _len, _ref;
      keys = [];
      bucket = {};
      bucketValue = {};
      _ref = f.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        key = split(d);
        if (!bucket[key]) {
          keys.push(key);
          bucket[key] = [];
          bucketValue[key] = key;
        }
        bucket[key].push(d);
      }
      return keys.map(function(key) {
        var node, prop, stage;
        prop = {};
        prop[name] = bucketValue[key];
        stage = f.getStage();
        node = f.node.append('g');
        return new Segment({
          parent: f,
          data: bucket[key],
          stage: stage,
          prop: prop,
          node: node
        });
      });
    });
    return makeFacetArray(segmentGroup);
  };

  facetArrayPrototype.layout = function(layout) {
    var parentSegment, segmentGroup, _i, _len;
    if (typeof layout !== 'function') {
      throw new TypeError("Layout must be a function");
    }
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      segmentGroup = this[_i];
      parentSegment = segmentGroup[0].parent;
      if (!parentSegment) {
        throw new Error("You must split before calling layout");
      }
      layout(parentSegment, segmentGroup);
    }
    return this;
  };

  facetArrayPrototype.apply = function(name, apply) {
    if (typeof apply !== 'function') {
      throw new TypeError("Apply must be a function");
    }
    this._eachSegment(function(segment) {
      return segment.prop[name] = apply(segment.data);
    });
    return this;
  };

  facetArrayPrototype.combine = function(_arg) {
    var filter, limit, segmentGroup, sort, _i, _j, _len, _len1, _ref;
    _ref = _arg != null ? _arg : {}, filter = _ref.filter, sort = _ref.sort, limit = _ref.limit;
    if (filter) {
      if (typeof filter !== 'function') {
        throw new TypeError("filter must be a function");
      }
    }
    if (sort) {
      if (typeof sort !== 'function') {
        throw new TypeError("sort must be a function");
      }
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        segmentGroup = this[_i];
        segmentGroup.sort(sort);
      }
    }
    if (limit != null) {
      for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
        segmentGroup = this[_j];
        segmentGroup.splice(limit, segmentGroup.length - limit);
      }
    }
    return this;
  };

  facetArrayPrototype.stage = function(transform) {
    this._eachSegment(transform);
    return this;
  };

  facetArrayPrototype.pop = function() {
    this._eachSegment(function(segment) {
      return segment.popStage();
    });
    return this;
  };

  facetArrayPrototype.plot = function(plot) {
    this._eachSegment(plot);
    return this;
  };

  facetArrayPrototype.render = function() {
    return this;
  };

  makeFacetArray = function(arr) {
    return arraySubclass(arr, facetArrayPrototype);
  };

  facet.canvas = function(selector, width, height, data) {
    var svg;
    svg = d3.select(selector).append('svg').attr('width', width).attr('height', height);
    return makeFacetArray([
      [
        new Segment({
          parent: null,
          data: data,
          node: svg,
          stage: {
            type: 'rectangle',
            width: width,
            height: height
          },
          prop: {}
        })
      ]
    ]);
  };

  facet.driver = {
    simple: function(data) {
      return function(query, callback) {};
    }
  };

}).call(this);
