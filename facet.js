// Generated by CoffeeScript 1.3.1
(function() {
  var FacetJob, Segment, applyFns, arraySubclass, divideLength, exports, facet, flatten, simple, simpleDriver, sortFns, splitFns, stripeTile;

  arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
    return array;
  } : function(array, prototype) {
    var property, _i, _len;
    for (_i = 0, _len = prototype.length; _i < _len; _i++) {
      property = prototype[_i];
      array[property] = prototype[property];
    }
    return array;
  };

  flatten = function(ar) {
    return Array.prototype.concat.apply([], ar);
  };

  Segment = (function() {

    Segment.name = 'Segment';

    function Segment(_arg) {
      var stage;
      this.parent = _arg.parent, this.node = _arg.node, stage = _arg.stage, this.prop = _arg.prop, this.splits = _arg.splits;
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack = [stage];
    }

    Segment.prototype.getStage = function() {
      return this._stageStack[this._stageStack.length - 1];
    };

    Segment.prototype.setStage = function(stage) {
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack[this._stageStack.length - 1] = stage;
    };

    Segment.prototype.pushStage = function(stage) {
      if (typeof (stage != null ? stage.type : void 0) !== 'string') {
        throw "invalid stage";
      }
      this._stageStack.push(stage);
    };

    Segment.prototype.popStage = function() {
      if (this._stageStack.length < 2) {
        throw "must have at least one stage";
      }
      this._stageStack.pop();
    };

    return Segment;

  })();

  window.facet = facet = {};

  facet.split = {
    natural: function(attribute) {
      return {
        bucket: 'natural',
        attribute: attribute
      };
    },
    even: function(attribute, size, offset) {
      return {
        bucket: 'even',
        attribute: attribute,
        size: size,
        offset: offset
      };
    }
  };

  facet.apply = {
    count: function() {
      return {
        aggregate: 'count'
      };
    },
    sum: function(attribute) {
      return {
        aggregate: 'sum',
        attribute: attribute
      };
    },
    average: function(attribute) {
      return {
        aggregate: 'sum',
        attribute: attribute
      };
    },
    min: function(attribute) {
      return {
        aggregate: 'min',
        attribute: attribute
      };
    },
    max: function(attribute) {
      return {
        aggregate: 'max',
        attribute: attribute
      };
    },
    unique: function(attribute) {
      return {
        aggregate: 'unique',
        attribute: attribute
      };
    }
  };

  facet.prop = function(propName) {
    return function(segment) {
      return segment.prop[propName];
    };
  };

  divideLength = function(length, sizes) {
    var lengthPerSize, size, totalSize, _i, _len;
    totalSize = 0;
    for (_i = 0, _len = sizes.length; _i < _len; _i++) {
      size = sizes[_i];
      totalSize += size;
    }
    lengthPerSize = length / totalSize;
    return sizes.map(function(size) {
      return size * lengthPerSize;
    });
  };

  stripeTile = function(dim1, dim2) {
    var makeTransform;
    makeTransform = function(dim, value) {
      if (dim === 'width') {
        return "translate(" + value + ",0)";
      } else {
        return "translate(0," + value + ")";
      }
    };
    return function(_arg) {
      var gap, size, _ref;
      _ref = _arg != null ? _arg : {}, gap = _ref.gap, size = _ref.size;
      return function(parentSegment, segmentGroup) {
        var availableDim1, curDim1, dim1s, dimSoFar, i, maxGap, n, parentDim1, parentDim2, parentStage, segment, segmentStage, _i, _len;
        gap || (gap = 0);
        size || (size = function() {
          return 1;
        });
        n = segmentGroup.length;
        parentStage = parentSegment.getStage();
        if (parentStage.type !== 'rectangle') {
          throw new Error("Must have a rectangular stage (is " + parentStage.type + ")");
        }
        parentDim1 = parentStage[dim1];
        parentDim2 = parentStage[dim2];
        maxGap = Math.max(0, (parentDim1 - n * 2) / (n - 1));
        gap = Math.min(gap, maxGap);
        availableDim1 = parentDim1 - gap * (n - 1);
        dim1s = divideLength(availableDim1, segmentGroup.map(size));
        dimSoFar = 0;
        for (i = _i = 0, _len = segmentGroup.length; _i < _len; i = ++_i) {
          segment = segmentGroup[i];
          curDim1 = dim1s[i];
          segmentStage = {
            type: 'rectangle'
          };
          segmentStage[dim1] = curDim1;
          segmentStage[dim2] = parentDim2;
          segment.setStage(segmentStage);
          segment.node.attr('transform', makeTransform(dim1, dimSoFar)).attr(dim1, curDim1).attr(dim2, parentDim2);
          dimSoFar += curDim1 + gap;
        }
      };
    };
  };

  facet.layout = {
    overlap: function() {
      return {};
    },
    horizontal: stripeTile('width', 'height'),
    vertical: stripeTile('height', 'width'),
    tile: function() {}
  };

  facet.stage = {
    rectToPoint: function(xPos, yPos) {
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'rectangle') {
          throw new Error("Must have a rectangle stage (is " + stage.type + ")");
        }
        segment.pushStage({
          type: 'point',
          x: xPos * stage.width,
          y: yPos * stage.height
        });
      };
    }
  };

  facet.plot = {
    rect: function(_arg) {
      var color;
      color = _arg.color;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'rectangle') {
          throw new Error("Must have a rectangle stage (is " + stage.type + ")");
        }
        segment.node.append('rect').datum(segment).attr('width', stage.width).attr('height', stage.height).style('fill', color).style('stroke', 'black');
      };
    },
    text: function(_arg) {
      var color, text;
      color = _arg.color, text = _arg.text;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'point') {
          throw new Error("Must have a point stage (is " + stage.type + ")");
        }
        segment.node.append('text').datum(segment).attr('x', stage.x).attr('y', stage.y).attr('dy', '.71em').style('fill', color).text(text);
      };
    },
    circle: function(_arg) {
      var color;
      color = _arg.color;
      return function(segment) {
        var stage;
        stage = segment.getStage();
        if (stage.type !== 'point') {
          throw new Error("Must have a point stage (is " + stage.type + ")");
        }
        segment.node.append('text').datum(segment).attr('cx', stage.x).attr('cy', stage.y).attr('dy', '.71em').style('fill', color).text(text);
      };
    }
  };

  facet.sort = {
    natural: function(attribute, direction) {
      if (direction == null) {
        direction = 'ASC';
      }
      return {
        compare: 'natural',
        attribute: attribute,
        direction: direction
      };
    },
    caseInsensetive: function(attribute, direction) {
      if (direction == null) {
        direction = 'ASC';
      }
      return {
        compare: 'caseInsensetive',
        attribute: attribute,
        direction: direction
      };
    }
  };

  FacetJob = (function() {

    FacetJob.name = 'FacetJob';

    function FacetJob(driver) {
      this.driver = driver;
      this.ops = [];
    }

    FacetJob.prototype.split = function(propName, split) {
      split = _.clone(split);
      split.operation = 'split';
      split.prop = propName;
      this.ops.push(split);
      return this;
    };

    FacetJob.prototype.layout = function(layout) {
      if (typeof layout !== 'function') {
        throw new TypeError("Layout must be a function");
      }
      this.ops.push({
        operation: 'layout',
        layout: layout
      });
      return this;
    };

    FacetJob.prototype.apply = function(propName, apply) {
      apply = _.clone(apply);
      apply.operation = 'apply';
      apply.prop = propName;
      this.ops.push(apply);
      return this;
    };

    FacetJob.prototype.combine = function(_arg) {
      var combine, filter, limit, sort, _ref;
      _ref = _arg != null ? _arg : {}, filter = _ref.filter, sort = _ref.sort, limit = _ref.limit;
      combine = {
        operation: 'combine'
      };
      if (sort) {
        combine.sort = sort;
      }
      if (limit != null) {
        combine.limit = limit;
      }
      this.ops.push(combine);
      return this;
    };

    FacetJob.prototype.stage = function(transform) {
      if (typeof transform !== 'function') {
        throw new TypeError("transform must be a function");
      }
      this.ops.push({
        operation: 'stage',
        transform: transform
      });
      return this;
    };

    FacetJob.prototype.pop = function() {
      this.ops.push({
        operation: 'pop'
      });
      return this;
    };

    FacetJob.prototype.plot = function(plot) {
      if (typeof plot !== 'function') {
        throw new TypeError("plot must be a function");
      }
      this.ops.push({
        operation: 'plot',
        plot: plot
      });
      return this;
    };

    FacetJob.prototype.render = function(selector, width, height) {
      var operations, parent, query;
      parent = d3.select(selector);
      if (parent.empty()) {
        throw new Error("could not find the provided selector");
      }
      if (!(width && height)) {
        throw new Error("bad size: " + width + " x " + height);
      }
      operations = this.ops;
      query = operations.filter(function(_arg) {
        var operation;
        operation = _arg.operation;
        return operation === 'split' || operation === 'apply' || operation === 'combine';
      });
      this.driver(query, function(err, res) {
        var cmd, layout, parentSegment, plot, segment, segmentGroup, segmentGroups, svg, transform, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p;
        if (err) {
          alert("An error has occurred");
          throw err;
        }
        svg = parent.append('svg').attr('width', width).attr('height', height);
        segmentGroups = [
          [
            new Segment({
              parent: null,
              node: svg,
              stage: {
                type: 'rectangle',
                width: width,
                height: height
              },
              prop: res.prop,
              splits: res.splits
            })
          ]
        ];
        for (_i = 0, _len = operations.length; _i < _len; _i++) {
          cmd = operations[_i];
          switch (cmd.operation) {
            case 'split':
              segmentGroups = flatten(segmentGroups).map(function(segment) {
                return segment.splits.map(function(sp) {
                  return new Segment({
                    parent: segment,
                    node: segment.node.append('g'),
                    stage: segment.getStage(),
                    prop: sp.prop,
                    splits: sp.splits
                  });
                });
              });
              break;
            case 'apply':
            case 'combine':
              null;

              break;
            case 'layout':
              layout = cmd.layout;
              for (_j = 0, _len1 = segmentGroups.length; _j < _len1; _j++) {
                segmentGroup = segmentGroups[_j];
                parentSegment = segmentGroup[0].parent;
                if (!parentSegment) {
                  throw new Error("You must split before calling layout");
                }
                layout(parentSegment, segmentGroup);
              }
              break;
            case 'stage':
              transform = cmd.transform;
              for (_k = 0, _len2 = segmentGroups.length; _k < _len2; _k++) {
                segmentGroup = segmentGroups[_k];
                for (_l = 0, _len3 = segmentGroup.length; _l < _len3; _l++) {
                  segment = segmentGroup[_l];
                  transform(segment);
                }
              }
              break;
            case 'pop':
              for (_m = 0, _len4 = segmentGroups.length; _m < _len4; _m++) {
                segmentGroup = segmentGroups[_m];
                for (_n = 0, _len5 = segmentGroup.length; _n < _len5; _n++) {
                  segment = segmentGroup[_n];
                  segment.popStage();
                }
              }
              break;
            case 'plot':
              plot = cmd.plot;
              for (_o = 0, _len6 = segmentGroups.length; _o < _len6; _o++) {
                segmentGroup = segmentGroups[_o];
                for (_p = 0, _len7 = segmentGroup.length; _p < _len7; _p++) {
                  segment = segmentGroup[_p];
                  plot(segment);
                }
              }
              break;
            default:
              throw new Error("Unknown operation '" + cmd.operation + "'");
          }
        }
      });
      return this;
    };

    return FacetJob;

  })();

  facet.canvas = function(driver) {
    return new FacetJob(driver);
  };

  facet.driver = {};

  null;


  flatten = function(ar) {
    return Array.prototype.concat.apply([], ar);
  };

  splitFns = {
    natural: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(d) {
        return d[attribute];
      };
    },
    even: function(_arg) {
      var attribute, offset, size;
      attribute = _arg.attribute, size = _arg.size, offset = _arg.offset;
      return function(d) {
        var b;
        b = Math.floor((d[attribute] + offset) / size) * size;
        return [b, b + size];
      };
    },
    timeSecond: function(attribute) {
      return function(d) {
        var de, ds;
        ds = new Date(d[attribute]);
        ds.setUTCMilliseconds(0);
        de = new Date(ds);
        de.setUTCMilliseconds(1000);
        return [ds, de];
      };
    },
    timeMinute: function(attribute) {
      return function(d) {
        var de, ds;
        ds = new Date(d[attribute]);
        ds.setUTCSeconds(0, 0);
        de = new Date(ds);
        de.setUTCSeconds(60);
        return [ds, de];
      };
    },
    timeHour: function(attribute) {
      return function(d) {
        var de, ds;
        ds = new Date(d[attribute]);
        ds.setUTCMinutes(0, 0, 0);
        de = new Date(ds);
        de.setUTCMinutes(60);
        return [ds, de];
      };
    },
    timeDay: function(attribute) {
      return function(d) {
        var de, ds;
        ds = new Date(d[attribute]);
        ds.setUTCHours(0, 0, 0, 0);
        de = new Date(ds);
        de.setUTCHours(24);
        return [ds, de];
      };
    }
  };

  applyFns = {
    count: function() {
      return function(ds) {
        return ds.length;
      };
    },
    sum: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        });
      };
    },
    average: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        }) / ds.length;
      };
    },
    min: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(ds) {
        return d3.min(ds, function(d) {
          return d[attribute];
        });
      };
    },
    max: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(ds) {
        return d3.max(ds, function(d) {
          return d[attribute];
        });
      };
    },
    unique: function(_arg) {
      var attribute;
      attribute = _arg.attribute;
      return function(ds) {
        var count, d, seen, v, _i, _len;
        seen = {};
        count = 0;
        for (_i = 0, _len = ds.length; _i < _len; _i++) {
          d = ds[_i];
          v = d[attribute];
          if (!seen[v]) {
            count++;
            seen[v] = 1;
          }
        }
        return count;
      };
    }
  };

  sortFns = {
    natural: function(_arg) {
      var cmpFn, direction, prop;
      prop = _arg.prop, direction = _arg.direction;
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(a.prop[prop], b.prop[prop]);
      };
    },
    caseInsensetive: function(_arg) {
      var cmpFn, direction, prop;
      prop = _arg.prop, direction = _arg.direction;
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(String(a.prop[prop]).toLowerCase(), String(b.prop[prop]).toLowerCase());
      };
    }
  };

  simpleDriver = function(data, query) {
    var applyFn, cmd, propName, rootSegment, segment, segmentGroup, segmentGroups, sortFn, splitFn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p;
    rootSegment = {
      raw: data,
      prop: {}
    };
    segmentGroups = [[rootSegment]];
    for (_i = 0, _len = query.length; _i < _len; _i++) {
      cmd = query[_i];
      switch (cmd.operation) {
        case 'split':
          propName = cmd.prop;
          if (!propName) {
            throw new Error("'prop' not defined in apply");
          }
          splitFn = splitFns[cmd.bucket](cmd);
          if (!splitFn) {
            throw new Error("No such bucket `" + cmd.bucket + "` in split");
          }
          segmentGroups = flatten(segmentGroups).map(function(segment) {
            var bucketValue, buckets, d, key, keys, _j, _len1, _ref;
            keys = [];
            buckets = {};
            bucketValue = {};
            _ref = segment.raw;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              d = _ref[_j];
              key = splitFn(d);
              if (!buckets[key]) {
                keys.push(key);
                buckets[key] = [];
                bucketValue[key] = key;
              }
              buckets[key].push(d);
            }
            segment.splits = keys.map(function(key) {
              var prop;
              prop = {};
              prop[propName] = bucketValue[key];
              return {
                raw: buckets[key],
                prop: prop
              };
            });
            delete segment.raw;
            return segment.splits;
          });
          break;
        case 'apply':
          propName = cmd.prop;
          if (!propName) {
            throw new Error("'prop' not defined in apply");
          }
          applyFn = applyFns[cmd.aggregate](cmd);
          if (!applyFn) {
            throw new Error("No such aggregate `" + cmd.aggregate + "` in apply");
          }
          for (_j = 0, _len1 = segmentGroups.length; _j < _len1; _j++) {
            segmentGroup = segmentGroups[_j];
            for (_k = 0, _len2 = segmentGroup.length; _k < _len2; _k++) {
              segment = segmentGroup[_k];
              segment.prop[propName] = applyFn(segment.raw);
            }
          }
          break;
        case 'combine':
          if (cmd.sort) {
            for (_l = 0, _len3 = segmentGroups.length; _l < _len3; _l++) {
              segmentGroup = segmentGroups[_l];
              sortFn = sortFns[cmd.sort.compare](cmd.sort);
              if (!sortFn) {
                throw new Error("No such compare `" + cmd.sort.compare + "` in combine.sort");
              }
              for (_m = 0, _len4 = segmentGroups.length; _m < _len4; _m++) {
                segmentGroup = segmentGroups[_m];
                segmentGroup.sort(sortFn);
              }
            }
          }
          if (cmd.limit != null) {
            for (_n = 0, _len5 = segmentGroups.length; _n < _len5; _n++) {
              segmentGroup = segmentGroups[_n];
              segmentGroup.splice(limit, segmentGroup.length - limit);
            }
          }
          break;
        default:
          throw new Error("Unknown operation '" + cmd.operation + "'");
      }
    }
    for (_o = 0, _len6 = segmentGroups.length; _o < _len6; _o++) {
      segmentGroup = segmentGroups[_o];
      for (_p = 0, _len7 = segmentGroup.length; _p < _len7; _p++) {
        segment = segmentGroup[_p];
        delete segment.raw;
      }
    }
    return rootSegment;
  };

  simple = function(data) {
    return function(query, callback) {
      var result;
      if (callback == null) {
        callback = function() {};
      }
      try {
        result = simpleDriver(data, query);
      } catch (e) {
        callback(e, null);
        return;
      }
      callback(null, result);
    };
  };

  if ((facet != null ? facet.driver : void 0) != null) {
    facet.driver.simple = simple;
  }

  if (exports) {
    exports = simple;
  }

  null;


}).call(this);
