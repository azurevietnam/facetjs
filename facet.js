// Generated by CoffeeScript 1.3.1
(function() {
  var arraySubclass, divideLength, facet, facetArrayPrototype, flatten, makeFacetArray, stripeTile;

  window.data1 = (function() {
    var now, pick, w;
    pick = function(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    };
    now = Date.now();
    w = 100;
    return d3.range(400).map(function(i) {
      return {
        id: i,
        time: new Date(now + i * 13 * 1000),
        letter: 'ABC'[Math.floor(3 * i / 400)],
        number: pick([1, 10, 3, 4]),
        scoreA: i * Math.random() * Math.random(),
        scoreB: 10 * Math.random(),
        walk: w += Math.random() - 0.5 + 0.02
      };
    });
  })();

  arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
    return array;
  } : function(array, prototype) {
    var property, _i, _len;
    for (_i = 0, _len = prototype.length; _i < _len; _i++) {
      property = prototype[_i];
      array[property] = prototype[property];
    }
    return array;
  };

  flatten = function(ar) {
    return Array.prototype.concat.apply([], ar);
  };

  window.facet = facet = {};

  facet.split = {
    natural: function(attribute) {
      return function(d) {
        return d[attribute];
      };
    },
    bucket: function(attribute, size, offset) {
      return function(d) {
        var b;
        b = Math.floor((d[attribute] + offset) / size) * size;
        return "" + b + ";" + (b + size);
      };
    },
    timeBucket: function(attribute) {
      return function(d) {
        return d.getHour();
      };
    }
  };

  facet.apply = {
    count: function() {
      return function(ds) {
        return ds.length;
      };
    },
    sum: function(attribute) {
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        });
      };
    },
    average: function(attribute) {
      return function(ds) {
        return d3.sum(ds, function(d) {
          return d[attribute];
        }) / ds.length;
      };
    },
    min: function(attribute) {
      return function(ds) {
        return d3.min(ds, function(d) {
          return d[attribute];
        });
      };
    },
    max: function(attribute) {
      return function(ds) {
        return d3.max(ds, function(d) {
          return d[attribute];
        });
      };
    },
    unique: function(attribute) {
      return function(ds) {
        var count, d, seen, v, _i, _len;
        seen = {};
        count = 0;
        for (_i = 0, _len = ds.length; _i < _len; _i++) {
          d = ds[_i];
          v = d[attribute];
          if (!seen[v]) {
            count++;
            seen[v] = 1;
          }
        }
        return count;
      };
    }
  };

  facet.prop = function(propName) {
    return function(segment) {
      return segment.prop[propName];
    };
  };

  divideLength = function(length, sizes) {
    var lengthPerSize, size, totalSize, _i, _len;
    totalSize = 0;
    for (_i = 0, _len = sizes.length; _i < _len; _i++) {
      size = sizes[_i];
      totalSize += size;
    }
    lengthPerSize = length / totalSize;
    return sizes.map(function(size) {
      return size * lengthPerSize;
    });
  };

  stripeTile = function(dim1, dim2) {
    var makeTransform;
    makeTransform = function(dim, value) {
      if (dim === 'width') {
        return "translate(" + value + ",0)";
      } else {
        return "translate(0," + value + ")";
      }
    };
    return function(_arg) {
      var gap, size, _ref;
      _ref = _arg != null ? _arg : {}, gap = _ref.gap, size = _ref.size;
      return function(parentSegment, segmentGroup) {
        var availableDim1, curDim1, dim1s, dimSoFar, i, maxGap, n, parentDim1, parentDim2, parentSize, segment, segmentSize, _i, _len;
        gap || (gap = 0);
        size || (size = function() {
          return 1;
        });
        n = segmentGroup.length;
        parentSize = parentSegment.size;
        parentDim1 = parentSize[dim1];
        parentDim2 = parentSize[dim2];
        maxGap = Math.max(0, (parentDim1 - n * 2) / (n - 1));
        gap = Math.min(gap, maxGap);
        availableDim1 = parentDim1 - gap * (n - 1);
        dim1s = divideLength(availableDim1, segmentGroup.map(size));
        dimSoFar = 0;
        for (i = _i = 0, _len = segmentGroup.length; _i < _len; i = ++_i) {
          segment = segmentGroup[i];
          curDim1 = dim1s[i];
          segmentSize = {};
          segmentSize[dim1] = curDim1;
          segmentSize[dim2] = parentDim2;
          segment.size = segmentSize;
          segment.node.attr('transform', makeTransform(dim1, dimSoFar)).attr(dim1, curDim1).attr(dim2, parentDim2);
          dimSoFar += curDim1 + gap;
        }
      };
    };
  };

  facet.layout = {
    overlap: function() {
      return {};
    },
    horizontal: stripeTile('width', 'height'),
    vertical: stripeTile('height', 'width'),
    tile: function() {}
  };

  facet.plot = {
    rect: function(_arg) {
      var color;
      color = _arg.color;
      return function(_arg1) {
        var node, prop, size;
        size = _arg1.size, node = _arg1.node, prop = _arg1.prop;
        node.append('rect').datum({
          size: size,
          prop: prop
        }).attr('width', size.width).attr('height', size.height).style('fill', color).style('stroke', 'black');
      };
    },
    text: function(_arg) {
      var color, text;
      color = _arg.color, text = _arg.text;
      return function(_arg1) {
        var node, prop, size;
        size = _arg1.size, node = _arg1.node, prop = _arg1.prop;
        node.append('text').datum({
          size: size,
          prop: prop
        }).attr('dy', '.71em').style('fill', color).text(text);
      };
    },
    circle: function(_arg) {
      var color;
      color = _arg.color;
      return function(_arg1) {
        var node, prop, size;
        size = _arg1.size, node = _arg1.node, prop = _arg1.prop;
        node.append('text').datum({
          size: size,
          prop: prop
        }).attr('dy', '.71em').style('fill', color).text(text);
      };
    }
  };

  facet.sort = {
    natural: function(attribute, direction) {
      var cmpFn;
      if (direction == null) {
        direction = 'ASC';
      }
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(a.prop[attribute], b.prop[attribute]);
      };
    },
    caseInsensetive: function() {
      var cmpFn, direction;
      direction = direction.toUpperCase();
      if (!(direction === 'ASC' || direction === 'DESC')) {
        throw "direction has to be 'ASC' or 'DESC'";
      }
      cmpFn = direction === 'ASC' ? d3.ascending : d3.descending;
      return function(a, b) {
        return cmpFn(String(a.prop[attribute]).toLowerCase(), String(b.prop[attribute]).toLowerCase());
      };
    }
  };

  facetArrayPrototype = [];

  facetArrayPrototype.split = function(name, split) {
    var segmentGroup;
    if (typeof split !== 'function') {
      throw new TypeError("Split must be a function");
    }
    segmentGroup = flatten(this).map(function(f) {
      var bucket, bucketValue, d, key, keys, _i, _len, _ref;
      keys = [];
      bucket = {};
      bucketValue = {};
      _ref = f.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        key = split(d);
        if (!bucket[key]) {
          keys.push(key);
          bucket[key] = [];
          bucketValue[key] = key;
        }
        bucket[key].push(d);
      }
      return keys.map(function(key) {
        var node, prop, size;
        prop = {};
        prop[name] = bucketValue[key];
        size = f.size;
        node = f.node.append('g').attr('width', size.width).attr('height', size.height);
        return {
          parent: f,
          data: bucket[key],
          size: size,
          prop: prop,
          node: node
        };
      });
    });
    return makeFacetArray(segmentGroup);
  };

  facetArrayPrototype.layout = function(layout) {
    var segmentGroup, _i, _len;
    if (typeof layout !== 'function') {
      throw new TypeError("Layout must be a function");
    }
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      segmentGroup = this[_i];
      layout(segmentGroup[0].parent, segmentGroup);
    }
    return this;
  };

  facetArrayPrototype.apply = function(name, apply) {
    var segment, segmentGroup, _i, _j, _len, _len1;
    if (typeof apply !== 'function') {
      throw new TypeError("Apply must be a function");
    }
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      segmentGroup = this[_i];
      for (_j = 0, _len1 = segmentGroup.length; _j < _len1; _j++) {
        segment = segmentGroup[_j];
        segment.prop[name] = apply(segment.data);
      }
    }
    return this;
  };

  facetArrayPrototype.combine = function(_arg) {
    var filter, limit, segmentGroup, sort, _i, _j, _len, _len1, _ref;
    _ref = _arg != null ? _arg : {}, filter = _ref.filter, sort = _ref.sort, limit = _ref.limit;
    if (filter) {
      if (typeof filter !== 'function') {
        throw new TypeError("filter must be a function");
      }
    }
    if (sort) {
      if (typeof sort !== 'function') {
        throw new TypeError("sort must be a function");
      }
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        segmentGroup = this[_i];
        segmentGroup.sort(sort);
      }
    }
    if (limit != null) {
      for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
        segmentGroup = this[_j];
        segmentGroup.splice(limit, segmentGroup.length - limit);
      }
    }
    return this;
  };

  facetArrayPrototype.plot = function(plot) {
    var segment, segmentGroup, _i, _j, _len, _len1;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      segmentGroup = this[_i];
      for (_j = 0, _len1 = segmentGroup.length; _j < _len1; _j++) {
        segment = segmentGroup[_j];
        plot(segment);
      }
    }
    return this;
  };

  makeFacetArray = function(arr) {
    return arraySubclass(arr, facetArrayPrototype);
  };

  facet.canvas = function(selector, width, height, data) {
    var svg;
    svg = d3.select(selector).append('svg').attr('width', width).attr('height', height);
    return makeFacetArray([
      [
        {
          parent: null,
          data: data,
          node: svg,
          size: {
            width: width,
            height: height
          },
          prop: {}
        }
      ]
    ]);
  };

}).call(this);
