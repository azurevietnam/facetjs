// Generated by CoffeeScript 1.3.1
(function() {
  var condenseQuery, condensedQueryToDruid, druid, flatten;

  flatten = function(ar) {
    return Array.prototype.concat.apply([], ar);
  };

  condenseQuery = function(query) {
    var cmd, condenseted, curQuery, _i, _len;
    curQuery = {
      split: null,
      applies: [],
      combine: null
    };
    condenseted = [];
    for (_i = 0, _len = query.length; _i < _len; _i++) {
      cmd = query[_i];
      switch (cmd.operation) {
        case 'split':
          condenseted.push(curQuery);
          curQuery = {
            split: cmd,
            applies: [],
            combine: null
          };
          break;
        case 'apply':
          curQuery.applies.push(cmd);
          break;
        case 'combine':
          if (curQuery.combine) {
            throw new Error("Can not have more than one combine");
          }
          curQuery.combine = cmd;
          break;
        default:
          throw new Error("Unknown operation '" + cmd.operation + "'");
      }
    }
    condenseted.push(curQuery);
    return condenseted;
  };

  condensedQueryToDruid = function(_arg, callback) {
    var apply, bucketDuration, combinePropName, condensedQuery, countPropName, dataSource, druidQuery, filters, findApply, findCountApply, intervals, requester, timePropName, _i, _len, _ref, _ref1, _ref2;
    requester = _arg.requester, dataSource = _arg.dataSource, intervals = _arg.intervals, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
    findApply = function(applies, propName) {
      var apply, _i, _len;
      for (_i = 0, _len = applies.length; _i < _len; _i++) {
        apply = applies[_i];
        if (apply.prop === propName) {
          return apply;
        }
      }
    };
    findCountApply = function(applies) {
      var apply, _i, _len;
      for (_i = 0, _len = applies.length; _i < _len; _i++) {
        apply = applies[_i];
        if (apply.aggregate === 'count') {
          return apply;
        }
      }
    };
    if (condensedQuery.applies.length === 0) {
      callback(null, {});
      return;
    }
    druidQuery = {
      dataSource: dataSource,
      intervals: intervals
    };
    if (filters) {
      druidQuery.filters = filters;
    }
    if (condensedQuery.split) {
      if (!((_ref = condensedQuery.combine) != null ? _ref.sort : void 0)) {
        callback("must have a sort combine for a split");
        return;
      }
      combinePropName = condensedQuery.combine.sort.prop;
      if (!combinePropName) {
        callback("must have a sort prop name");
        return;
      }
      switch (condensedQuery.split.bucket) {
        case 'natural':
          if (findApply(condensedQuery.applies, combinePropName)) {
            if (!condensedQuery.split.attribute) {
              callback("split must have an attribute");
              return;
            }
            if (!condensedQuery.split.prop) {
              callback("split must have a prop");
              return;
            }
            druidQuery.queryType = "topN";
            druidQuery.granularity = "all";
            druidQuery.dimension = {
              type: 'default',
              dimension: condensedQuery.split.attribute,
              outputName: condensedQuery.split.prop
            };
            druidQuery.threshold = condensedQuery.combine.limit || 10;
            druidQuery.metric = combinePropName;
          } else {
            callback("not supported yet");
            return;
          }
          break;
        case 'time':
          druidQuery.queryType = "timeseries";
          timePropName = condensedQuery.split.prop;
          if (combinePropName !== timePropName) {
            callback("Must sort on the time prop for now (temp)");
          }
          return;
          bucketDuration = condensedQuery.split.duration;
          if (!bucketDuration) {
            callback("Must have duration for time bucket");
            return;
          }
          if ((_ref1 = !bucketDuration) === 'second' || _ref1 === 'minute' || _ref1 === 'hour' || _ref1 === 'day') {
            callback("Unsupported duration '" + bucketDuration + "' in time bucket");
            return;
          }
          druidQuery.granularity = bucketDuration;
          break;
        default:
          callback("Unsupported bucketing '" + condensedQuery.split.bucket + "' in split");
          return;
      }
    } else {
      druidQuery.queryType = "timeseries";
      druidQuery.granularity = "all";
    }
    if (condensedQuery.applies.length > 0) {
      countPropName = null;
      druidQuery.aggregations = [];
      _ref2 = condensedQuery.applies;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        apply = _ref2[_i];
        switch (apply.aggregate) {
          case 'count':
            countPropName = apply.prop;
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.prop,
              fieldName: 'count'
            });
            break;
          case 'sum':
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.prop,
              fieldName: apply.attribute
            });
            break;
          case 'average':
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.prop,
              fieldName: apply.attribute
            });
            break;
          case 'unique':
            callback("not implemented yet");
            return;
        }
      }
    }
    requester(druidQuery, function(err, ds) {
      var result;
      if (err) {
        callback(err);
        return;
      }
      if (condensedQuery.split) {
        switch (condensedQuery.split.bucket) {
          case 'natural':
            if (ds.length !== 1) {
              callback("something went wrong");
              return;
            }
            result = ds[0].result;
            break;
          case 'time':
            result = {
              "not": "implemented yet"
            };
            break;
          default:
            callback("Unsupported bucketing '" + condensedQuery.split.bucket + "' in split post process");
            return;
        }
      } else {
        if (ds.length !== 1) {
          callback("something went wrong");
          return;
        }
        result = ds.map(function(d) {
          return d.result;
        });
      }
      callback(null, result);
    });
  };

  druid = function(_arg) {
    var dataSource, end, filters, requester, start;
    requester = _arg.requester, dataSource = _arg.dataSource, start = _arg.start, end = _arg.end, filters = _arg.filters;
    return function(query, callback) {
      var cmdIndex, condensedQuery, intervals, queryDruid, rootSegemnt, segments;
      condensedQuery = condenseQuery(query);
      start = start.toISOString().replace('Z', '');
      end = end.toISOString().replace('Z', '');
      intervals = ["" + start + "/" + end];
      rootSegemnt = null;
      segments = [rootSegemnt];
      queryDruid = function(condensed, done) {
        var QUERY_LIMIT, queryFns;
        QUERY_LIMIT = 10;
        queryFns = async.mapLimit(segments, QUERY_LIMIT, function(parentSegment, done) {
          return condensedQueryToDruid({
            requester: requester,
            dataSource: dataSource,
            intervals: intervals,
            filters: null,
            condensedQuery: condensed
          }, function(err, props) {
            var splits;
            if (err) {
              done(err);
              return;
            }
            splits = props.map(function(prop) {
              return {
                prop: prop
              };
            });
            if (parentSegment) {
              parentSegment.splits = splits;
            } else {
              rootSegemnt = splits[0];
            }
            done(null, splits);
          });
        }, function(err, results) {
          if (err) {
            done(err);
            return;
          }
          segments = flatten(results);
          done();
        });
      };
      cmdIndex = 0;
      return async.whilst(function() {
        return cmdIndex < condensedQuery.length;
      }, function(done) {
        var condenced;
        condenced = condensedQuery[cmdIndex];
        cmdIndex++;
        queryDruid(condenced, done);
      }, function(err) {
        if (err) {
          callback(err);
          return;
        }
        callback(null, rootSegemnt);
      });
    };
  };

  if ((typeof facet !== "undefined" && facet !== null ? facet.driver : void 0) != null) {
    facet.driver.druid = druid;
  }

  if (typeof module !== 'undefined' && typeof exports !== 'undefined') {
    module.exports = druid;
  }

}).call(this);
