// Generated by CoffeeScript 1.3.1
(function() {
  var SQLQueryBuilder, andFilters, async, condensedQueryToSQL, driverUtil, exports, makeFilter, rq,
    __slice = [].slice;

  rq = function(module) {
    var moduleParts;
    if (typeof window === 'undefined') {
      return require(module);
    } else {
      moduleParts = module.split('/');
      return window[moduleParts[moduleParts.length - 1]];
    }
  };

  async = rq('async');

  driverUtil = rq('./driverUtil');

  if (typeof exports === 'undefined') {
    exports = {};
  }

  makeFilter = function(attribute, value) {
    if (Array.isArray(value)) {
      return {
        type: 'within',
        attribute: attribute,
        range: value
      };
    } else {
      return {
        type: 'is',
        attribute: attribute,
        value: value
      };
    }
  };

  andFilters = function() {
    var filters;
    filters = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    filters = filters.filter(function(filter) {
      return filter != null;
    });
    switch (filters.length) {
      case 0:
        return null;
      case 1:
        return filters[0];
      default:
        return {
          type: 'and',
          filters: filters
        };
    }
  };

  SQLQueryBuilder = (function() {

    SQLQueryBuilder.name = 'SQLQueryBuilder';

    function SQLQueryBuilder(table) {
      if (typeof table !== 'string') {
        throw new Error("must have table");
      }
      this.selectParts = [];
      this.groupByParts = [];
      this.filterPart = null;
      this.fromPart = "FROM " + (this.escapeAttribute(table));
      this.orderByPart = null;
      this.limitPart = null;
    }

    SQLQueryBuilder.prototype.escapeAttribute = function(attribute) {
      return "`" + attribute + "`";
    };

    SQLQueryBuilder.prototype.escapeValue = function(value) {
      return "\"" + value + "\"";
    };

    SQLQueryBuilder.prototype.filterToSQL = function(filter) {
      var attribute;
      switch (filter.type) {
        case 'is':
          return "" + (this.escapeAttribute(filter.attribute)) + " = " + (this.escapeValue(filter.value));
        case 'in':
          return "" + (this.escapeAttribute(filter.attribute)) + " in (" + (filter.values.map(this.escapeValue).join(',')) + ")";
        case 'match':
          return "" + (this.escapeAttribute(filter.attribute)) + " REGEXP '" + filter.expression + "'";
        case 'within':
          attribute = this.escapeAttribute(filter.attribute);
          return "" + filter.range[0] + " <= " + attribute + " AND " + attribute + " < " + filter.range[1];
        case 'not':
          return "NOT (" + (this.filterToSQL(filter.filter)) + ")";
        case 'and':
          return '(' + filter.filters.map(this.filterToSQL).join(') AND (') + ')';
        case 'or':
          return '(' + filter.filters.map(this.filterToSQL).join(') OR (') + ')';
        default:
          throw new Error("unknown filter type '" + filter.type + "'");
      }
    };

    SQLQueryBuilder.prototype.addFilter = function(filter) {
      this.filterPart = 'WHERE ' + this.filterToSQL(filter);
      return this;
    };

    SQLQueryBuilder.prototype.timeBucketing = {
      second: {
        select: '%Y-%m-%dT%H:%i:%SZ',
        group: '%Y-%m-%dT%H:%i:%SZ'
      },
      minute: {
        select: '%Y-%m-%dT%H:%i:00Z',
        group: '%Y-%m-%dT%H:%i'
      },
      hour: {
        select: '%Y-%m-%dT%H:00:00Z',
        group: '%Y-%m-%dT%H'
      },
      day: {
        select: '%Y-%m-%dT00:00:00Z',
        group: '%Y-%m-%d'
      },
      month: {
        select: '%Y-%m-00T00:00:00Z',
        group: '%Y-%m'
      },
      year: {
        select: '%Y-00-00T00:00:00Z',
        group: '%Y'
      }
    };

    SQLQueryBuilder.prototype.addSplit = function(split) {
      var bucketDuration, bucketSpec, floorStr, groupByPart, selectPart;
      switch (split.bucket) {
        case 'identity':
          selectPart = this.escapeAttribute(split.attribute);
          groupByPart = this.escapeAttribute(split.attribute);
          break;
        case 'continuous':
          floorStr = this.escapeAttribute(split.attribute);
          if (split.offset !== 0) {
            floorStr = "(" + floorStr + " + " + split.offset + ")";
          }
          if (split.size !== 1) {
            floorStr = "" + floorStr + " / " + split.size;
          }
          floorStr = "FLOOR(" + floorStr + ")";
          if (split.size !== 1) {
            floorStr = "" + floorStr + " * " + split.size;
          }
          if (split.offset !== 0) {
            floorStr = "" + floorStr + " - " + split.offset;
          }
          selectPart = floorStr;
          groupByPart = floorStr;
          break;
        case 'time':
          bucketDuration = split.duration;
          bucketSpec = this.timeBucketing[bucketDuration];
          if (!bucketSpec) {
            throw new Error("unsupported time bucketing duration '" + bucketDuration + "'");
          }
          selectPart = "DATE_FORMAT(" + (this.escapeAttribute(split.attribute)) + ", '" + bucketSpec.select + "')";
          groupByPart = "DATE_FORMAT(" + (this.escapeAttribute(split.attribute)) + ", '" + bucketSpec.group + "')";
          break;
        default:
          throw new Error("unsupported bucketing policy '" + split.bucket + "'");
      }
      this.selectParts.push("" + selectPart + " AS \"" + split.name + "\"");
      this.groupByParts.push("" + groupByPart);
      return this;
    };

    SQLQueryBuilder.prototype.applyToSQL = function(apply) {
      switch (apply.aggregate) {
        case 'constant':
          return "" + apply.value;
        case 'count':
          return "COUNT(1)";
        case 'sum':
          return "SUM(" + (this.escapeAttribute(apply.attribute)) + ")";
        case 'average':
          return "AVG(" + (this.escapeAttribute(apply.attribute)) + ")";
        case 'min':
          return "MIN(" + (this.escapeAttribute(apply.attribute)) + ")";
        case 'max':
          return "MAX(" + (this.escapeAttribute(apply.attribute)) + ")";
        case 'uniqueCount':
          return "COUNT(DISTINCT " + (this.escapeAttribute(apply.attribute)) + ")";
        case 'quantile':
          throw new Error("not implemented yet (ToDo)");
          break;
        case 'add':
          return "(" + (this.applyToSQL(apply.operands[0])) + " + " + (this.applyToSQL(apply.operands[1])) + ")";
        case 'subtract':
          return "(" + (this.applyToSQL(apply.operands[0])) + " - " + (this.applyToSQL(apply.operands[1])) + ")";
        case 'multiply':
          return "(" + (this.applyToSQL(apply.operands[0])) + " * " + (this.applyToSQL(apply.operands[1])) + ")";
        case 'divide':
          return "(" + (this.applyToSQL(apply.operands[0])) + " / " + (this.applyToSQL(apply.operands[1])) + ")";
        default:
          throw new Error("no such apply '" + apply.aggregate + "'");
      }
    };

    SQLQueryBuilder.prototype.addApply = function(apply) {
      this.selectParts.push("" + (this.applyToSQL(apply)) + " AS \"" + apply.name + "\"");
      return this;
    };

    SQLQueryBuilder.prototype.directionMap = {
      ascending: 'ASC',
      descending: 'DESC'
    };

    SQLQueryBuilder.prototype.addSort = function(sort) {
      var sqlDirection;
      if (!sort.prop) {
        throw new Error("must have a sort prop name");
      }
      if (!sort.direction) {
        throw new Error("must have a sort direction");
      }
      sqlDirection = this.directionMap[sort.direction];
      if (!sqlDirection) {
        throw new Error("invalid direction is: '" + sort.direction + "'");
      }
      switch (sort.compare) {
        case 'natural':
          this.orderByPart = "ORDER BY " + (this.escapeAttribute(sort.prop)) + " " + sqlDirection;
          break;
        case 'caseInsensetive':
          throw new Error("not implemented yet (ToDo)");
          break;
        default:
          throw new Error("unsupported compare '" + sort.compare + "'");
      }
      return this;
    };

    SQLQueryBuilder.prototype.addLimit = function(limit) {
      if (isNaN(limit)) {
        throw new Error("limit must be a number (is: " + limit + ")");
      }
      this.limitPart = "LIMIT " + limit;
      return this;
    };

    SQLQueryBuilder.prototype.getQuery = function() {
      var query;
      if (!this.selectParts.length) {
        return null;
      }
      query = ['SELECT', this.selectParts.join(', '), this.fromPart];
      if (this.filterPart) {
        query.push(this.filterPart);
      }
      if (this.groupByParts.length) {
        query.push('GROUP BY ' + this.groupByParts.join(', '));
      }
      if (this.orderByPart) {
        query.push(this.orderByPart);
      }
      if (this.limitPart) {
        query.push(this.limitPart);
      }
      return query.join(' ') + ';';
    };

    return SQLQueryBuilder;

  })();

  condensedQueryToSQL = function(_arg, callback) {
    var apply, combine, condensedQuery, filter, queryToRun, requester, split, sqlQuery, table, _i, _len, _ref;
    requester = _arg.requester, table = _arg.table, filter = _arg.filter, condensedQuery = _arg.condensedQuery;
    sqlQuery = new SQLQueryBuilder(table);
    try {
      if (filter) {
        sqlQuery.addFilter(filter);
      }
      split = condensedQuery.split;
      if (split) {
        sqlQuery.addSplit(split);
      }
      _ref = condensedQuery.applies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        apply = _ref[_i];
        sqlQuery.addApply(apply);
      }
      combine = condensedQuery.combine;
      if (combine) {
        if (combine.sort) {
          sqlQuery.addSort(combine.sort);
        }
        if (combine.limit != null) {
          sqlQuery.addLimit(combine.limit);
        }
      }
    } catch (e) {
      callback(e);
      return;
    }
    queryToRun = sqlQuery.getQuery();
    if (!queryToRun) {
      callback(null, [
        {
          prop: {}
        }
      ]);
      return;
    }
    requester(queryToRun, function(err, ds) {
      var d, splitAttribute, splitProp, splitSize, splits, start, _j, _len1;
      if (err) {
        callback(err);
        return;
      }
      if (condensedQuery.split) {
        splitAttribute = condensedQuery.split.attribute;
        splitProp = condensedQuery.split.name;
        if (condensedQuery.split.bucket === 'continuous') {
          splitSize = condensedQuery.split.size;
          for (_j = 0, _len1 = ds.length; _j < _len1; _j++) {
            d = ds[_j];
            start = d[splitProp];
            d[splitProp] = [start, start + splitSize];
          }
        }
        splits = ds.map(function(prop) {
          return {
            prop: prop,
            _filter: andFilters(filter, makeFilter(splitAttribute, prop[splitProp]))
          };
        });
      } else {
        splits = ds.map(function(prop) {
          return {
            prop: prop,
            _filter: filter
          };
        });
      }
      callback(null, splits);
    });
  };

  exports = function(_arg) {
    var filter, requester, table;
    requester = _arg.requester, table = _arg.table, filter = _arg.filter;
    return function(query, callback) {
      var cmdIndex, condensedQuery, querySQL, rootSegment, segments;
      condensedQuery = driverUtil.condenseQuery(query);
      rootSegment = null;
      segments = [rootSegment];
      querySQL = function(condensed, done) {
        var QUERY_LIMIT, queryFns;
        QUERY_LIMIT = 10;
        queryFns = async.mapLimit(segments, QUERY_LIMIT, function(parentSegment, done) {
          return condensedQueryToSQL({
            requester: requester,
            table: table,
            filter: parentSegment ? parentSegment._filter : filter,
            condensedQuery: condensed
          }, function(err, splits) {
            if (err) {
              done(err);
              return;
            }
            if (parentSegment) {
              parentSegment.splits = splits;
              driverUtil.cleanSegment(parentSegment);
            } else {
              rootSegment = splits[0];
            }
            done(null, splits);
          });
        }, function(err, results) {
          if (err) {
            done(err);
            return;
          }
          segments = driverUtil.flatten(results);
          done();
        });
      };
      cmdIndex = 0;
      return async.whilst(function() {
        return cmdIndex < condensedQuery.length;
      }, function(done) {
        var condenced;
        condenced = condensedQuery[cmdIndex];
        cmdIndex++;
        querySQL(condenced, done);
      }, function(err) {
        if (err) {
          callback(err);
          return;
        }
        segments.forEach(driverUtil.cleanSegment);
        callback(null, rootSegment);
      });
    };
  };

  if (typeof module === 'undefined') {
    window['sqlDriver'] = exports;
  } else {
    module.exports = exports;
  }

}).call(this);
