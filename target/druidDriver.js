// Generated by CoffeeScript 1.3.1
(function() {
  var DruidQueryBuilder, andFilters, async, driverUtil, druidQuery, exports, filterToDruidQuery, filterToDruidQueryHelper, makeFilter, rangeToDruidInterval, rq,
    __slice = [].slice;

  rq = function(module) {
    var moduleParts;
    if (typeof window === 'undefined') {
      return require(module);
    } else {
      moduleParts = module.split('/');
      return window[moduleParts[moduleParts.length - 1]];
    }
  };

  async = rq('async');

  driverUtil = rq('./driverUtil');

  if (typeof exports === 'undefined') {
    exports = {};
  }

  makeFilter = function(attribute, value) {
    if (Array.isArray(value)) {
      return {
        type: 'within',
        attribute: attribute,
        range: value
      };
    } else {
      return {
        type: 'is',
        attribute: attribute,
        value: value
      };
    }
  };

  andFilters = function() {
    var filters;
    filters = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    filters = filters.filter(function(filter) {
      return filter != null;
    });
    switch (filters.length) {
      case 0:
        return null;
      case 1:
        return filters[0];
      default:
        return {
          type: 'and',
          filters: filters
        };
    }
  };

  rangeToDruidInterval = function(interval) {
    return interval.map(function(d) {
      return d.toISOString().replace('Z', '');
    }).join('/');
  };

  filterToDruidQueryHelper = function(filter) {};

  filterToDruidQuery = function(filter, timeDimension, druidQuery) {
    if (filter.type === 'range' && filter.attribute === timeDimension) {
      druidQuery.intervals;
    }
  };

  DruidQueryBuilder = (function() {

    DruidQueryBuilder.name = 'DruidQueryBuilder';

    function DruidQueryBuilder(type, timeAttribute) {
      this.type = type;
      this.timeAttribute = timeAttribute;
      this.aggregations = [];
      this.postAggregations = [];
    }

    DruidQueryBuilder.prototype.filterToDruid = function(filter) {
      var f, fis, i, r0, r1, _i, _len, _ref, _ref1;
      switch (filter.type) {
        case 'is':
          if (filter.attribute === this.timeAttribute) {
            throw new Error("can not filter on specific time");
          }
          return [
            {
              type: 'selector',
              dimension: filter.attribute,
              value: filter.value
            }
          ];
        case 'in':
          if (filter.attribute === this.timeAttribute) {
            throw new Error("can not filter on specific time");
          }
          return [
            {
              type: 'or',
              fields: filter.values.map((function(value) {
                return {
                  type: 'selector',
                  dimension: filter.attribute,
                  value: value
                };
              }), this)
            }
          ];
        case 'match':
          if (filter.attribute === this.timeAttribute) {
            throw new Error("can not match filter time");
          }
          return [
            {
              type: "regex",
              dimension: filter.attribute,
              pattern: filter.expression
            }
          ];
        case 'within':
          r0 = filter.range[0];
          r1 = filter.range[1];
          if (filter.attribute === this.timeAttribute) {
            if (!(r0 instanceof Date && r1 instanceof Date)) {
              throw new Error("start and end must be dates");
            }
            return [null, ["" + (r0.toISOString().replace('Z', '')) + "/" + (r1.toISOString().replace('Z', ''))]];
          } else if (typeof r0 === 'number' && typeof r1 === 'number') {
            return [
              {
                type: 'javascript',
                dimension: filter.attribute,
                "function": "function(a){return a=~~a," + r0 + "<=a&&a<" + r1 + ";}"
              }
            ];
          } else {
            throw new Error("has to be a numeric range");
          }
          break;
        case 'not':
          _ref = this.filterToDruid(filter.filter), f = _ref[0], i = _ref[1];
          if (i) {
            throw new Error("can not apply a 'not' filter to a time interval");
          }
          return [
            {
              type: 'not',
              filed: f
            }
          ];
        case 'and':
          fis = filter.filters.map(this.filterToDruid, this);
          return [
            {
              type: 'and',
              fields: fis.map(function(d) {
                return d[0];
              })
            }, driverUtil.flatten(fis.map(function(d) {
              return d[1];
            }))
          ];
        case 'or':
          fis = filter.filters.map(this.filterToDruid, this);
          for (_i = 0, _len = fis.length; _i < _len; _i++) {
            _ref1 = fis[_i], f = _ref1[0], i = _ref1[1];
            if (i) {
              throw new Error("can not 'or' time");
            }
          }
          return {
            type: 'or',
            fields: fis.map(function(d) {
              return d[0];
            })
          };
        default:
          throw new Error("unknown filter type '" + filter.type + "'");
      }
    };

    DruidQueryBuilder.prototype.addFilter = function(filter) {
      var _ref;
      _ref = filterToDruid(filter), this.filter = _ref[0], this.intervals = _ref[1];
      return this;
    };

    DruidQueryBuilder.prototype.addAggregation = function(agg) {
      this.aggregations.push(agg);
    };

    DruidQueryBuilder.prototype.addPostAggregation = function(postAgg) {
      this.postAggregations.push(postAgg);
    };

    DruidQueryBuilder.prototype.addApplies = function(applies) {
      var a, apply, countApply, sumApply, _i, _j, _len, _len1;
      for (_i = 0, _len = applies.length; _i < _len; _i++) {
        apply = applies[_i];
        if (!apply.name) {
          throw new Error("apply must have a name");
        }
        switch (apply.aggregate) {
          case 'constant':
            druidQuery.postAggregations.push({
              type: "constant",
              name: apply.name,
              value: apply.value
            });
            break;
          case 'count':
            druidQuery.aggregations.push({
              type: "count",
              name: apply.name
            });
            break;
          case 'sum':
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.name,
              fieldName: apply.attribute
            });
            break;
          case 'average':
            countApply = findCountApply(applies);
            if (!countApply) {
              applies.push(countApply = {
                operation: 'apply',
                aggregate: 'count',
                prop: '_count'
              });
            }
            sumApply = null;
            for (_j = 0, _len1 = applies.length; _j < _len1; _j++) {
              a = applies[_j];
              if (a.aggregate === 'sum' && a.attribute === apply.attribute) {
                sumApply = a;
                break;
              }
            }
            if (!sumApply) {
              applies.push(sumApply = {
                operation: 'apply',
                aggregate: 'sum',
                prop: '_sum_' + apply.attribute,
                attribute: apply.attribute
              });
            }
            druidQuery.postAggregations.push({
              type: "arithmetic",
              name: apply.name,
              fn: "/",
              fields: [
                {
                  type: "fieldAccess",
                  fieldName: sumApply.name
                }, {
                  type: "fieldAccess",
                  fieldName: countApply.name
                }
              ]
            });
            break;
          case 'min':
            druidQuery.aggregations.push({
              type: "min",
              name: apply.name,
              fieldName: apply.attribute
            });
            break;
          case 'max':
            druidQuery.aggregations.push({
              type: "max",
              name: apply.name,
              fieldName: apply.attribute
            });
            break;
          case 'uniqueCount':
            druidQuery.aggregations.push({
              type: "hyperUnique",
              name: apply.name,
              fieldName: apply.attribute
            });
            break;
          case 'quantile':
            if (!apply.quantile) {
              throw new Error("quantile apply must have quantile");
            }
            druidQuery.aggregations.push({
              type: "approxHistogramFold",
              name: '_' + apply.attribute,
              fieldName: apply.attribute
            });
            druidQuery.postAggregations.push({
              type: "quantile",
              name: apply.name,
              fieldName: '_' + apply.attribute,
              probability: apply.quantile
            });
            break;
          default:
            throw new Error("No supported aggregation " + apply.aggregate);
        }
      }
    };

    return DruidQueryBuilder;

  })();

  druidQuery = {
    all: function(_arg, callback) {
      var condensedQuery, dataSource, filters, interval, queryObj, requester;
      requester = _arg.requester, dataSource = _arg.dataSource, interval = _arg.interval, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
      if ((interval != null ? interval.length : void 0) !== 2) {
        callback("Must have valid interval [start, end]");
        return;
      }
      if (condensedQuery.applies.length === 0) {
        callback(null, [
          {
            prop: {},
            _interval: interval,
            _filters: filters
          }
        ]);
        return;
      }
      queryObj = {
        dataSource: dataSource,
        intervals: [toDruidInterval(interval)],
        queryType: "timeseries",
        granularity: "all"
      };
      if (filters) {
        queryObj.filter = filters;
      }
      if (condensedQuery.applies.length > 0) {
        try {
          addApplies(queryObj, condensedQuery.applies);
        } catch (e) {
          callback(e);
          return;
        }
      }
      requester(queryObj, function(err, ds) {
        var splits;
        if (err) {
          callback(err);
          return;
        }
        if (ds.length !== 1) {
          callback("something went wrong");
          return;
        }
        splits = [
          {
            prop: ds[0].result,
            _interval: interval,
            _filters: filters
          }
        ];
        callback(null, splits);
      });
    },
    timeseries: function(_arg, callback) {
      var bucketDuration, combinePropName, condensedQuery, dataSource, filters, interval, queryObj, requester, timePropName, _ref, _ref1;
      requester = _arg.requester, dataSource = _arg.dataSource, interval = _arg.interval, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
      if ((interval != null ? interval.length : void 0) !== 2) {
        callback("Must have valid interval [start, end]");
        return;
      }
      if (condensedQuery.applies.length === 0) {
        callback(null, [
          {
            prop: {},
            _interval: interval,
            _filters: filters
          }
        ]);
        return;
      }
      queryObj = {
        dataSource: dataSource,
        intervals: [toDruidInterval(interval)],
        queryType: "timeseries"
      };
      if (filters) {
        queryObj.filter = filters;
      }
      if (!((_ref = condensedQuery.combine) != null ? _ref.sort : void 0)) {
        callback("must have a sort combine for a split");
        return;
      }
      combinePropName = condensedQuery.combine.sort.prop;
      if (!combinePropName) {
        callback("must have a sort prop name");
        return;
      }
      timePropName = condensedQuery.split.name;
      if (combinePropName !== timePropName) {
        callback("Must sort on the time prop for now (temp)");
        return;
      }
      bucketDuration = condensedQuery.split.duration;
      if (!bucketDuration) {
        callback("Must have duration for time bucket");
        return;
      }
      if ((_ref1 = !bucketDuration) === 'second' || _ref1 === 'minute' || _ref1 === 'hour' || _ref1 === 'day') {
        callback("Unsupported duration '" + bucketDuration + "' in time bucket");
        return;
      }
      queryObj.granularity = bucketDuration;
      if (condensedQuery.applies.length > 0) {
        try {
          addApplies(queryObj, condensedQuery.applies);
        } catch (e) {
          callback(e);
          return;
        }
      }
      requester(queryObj, function(err, ds) {
        var durationMap, limit, splits;
        if (err) {
          callback(err);
          return;
        }
        durationMap = {
          second: 1000,
          minute: 60 * 1000,
          hour: 60 * 60 * 1000,
          day: 24 * 60 * 60 * 1000
        };
        if (condensedQuery.combine.sort.direction === 'descending') {
          ds.reverse();
        }
        if (condensedQuery.combine.limit != null) {
          limit = condensedQuery.combine.limit;
          ds.splice(limit, ds.length - limit);
        }
        splits = ds.map(function(d) {
          var split, timestampEnd, timestampStart;
          timestampStart = new Date(d.timestamp);
          timestampEnd = new Date(timestampStart.valueOf() + durationMap[bucketDuration]);
          split = {
            prop: d.result,
            _interval: [timestampStart, timestampEnd],
            _filters: filters
          };
          split.prop[timePropName] = [timestampStart, timestampEnd];
          return split;
        });
        callback(null, splits);
      });
    },
    topN: function(_arg, callback) {
      var condensedQuery, dataSource, filters, interval, invertApply, queryObj, requester, sort, _ref;
      requester = _arg.requester, dataSource = _arg.dataSource, interval = _arg.interval, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
      if ((interval != null ? interval.length : void 0) !== 2) {
        callback("Must have valid interval [start, end]");
        return;
      }
      if (condensedQuery.applies.length === 0) {
        callback(null, [
          {
            prop: {},
            _interval: interval,
            _filters: filters
          }
        ]);
        return;
      }
      queryObj = {
        dataSource: dataSource,
        intervals: [toDruidInterval(interval)],
        queryType: "topN",
        granularity: "all"
      };
      if (filters) {
        queryObj.filter = filters;
      }
      if (!condensedQuery.split.attribute) {
        callback("split must have an attribute");
        return;
      }
      if (!condensedQuery.split.name) {
        callback("split must have a prop");
        return;
      }
      sort = condensedQuery.combine.sort;
      if ((_ref = sort.direction) !== 'ascending' && _ref !== 'descending') {
        callback("direction has to be 'ascending' or 'descending'");
        return;
      }
      if (sort.direction === 'descending') {
        invertApply = null;
      } else {
        invertApply = findApply(condensedQuery.applies, sort.prop);
        if (!invertApply) {
          callback("no apply to invert for bottomN");
          return;
        }
      }
      queryObj.dimension = {
        type: 'default',
        dimension: condensedQuery.split.attribute,
        outputName: condensedQuery.split.name
      };
      queryObj.threshold = condensedQuery.combine.limit || 10;
      queryObj.metric = (invertApply ? '_inv_' : '') + condensedQuery.combine.sort.prop;
      if (condensedQuery.applies.length > 0) {
        try {
          addApplies(queryObj, condensedQuery.applies, invertApply);
        } catch (e) {
          callback(e);
          return;
        }
      }
      if (invertApply) {
        queryObj.postAggregations.push({
          type: "arithmetic",
          name: '_inv_' + invertApply.prop,
          fn: "*",
          fields: [
            {
              type: "fieldAccess",
              fieldName: invertApply.prop
            }, {
              type: "constant",
              value: -1
            }
          ]
        });
      }
      if (queryObj.postAggregations.length === 0) {
        delete queryObj.postAggregations;
      }
      requester(queryObj, function(err, ds) {
        var filterAttribute, filterValueProp, splits;
        if (err) {
          callback(err);
          return;
        }
        if (ds.length !== 1) {
          callback("something went wrong");
          return;
        }
        filterAttribute = condensedQuery.split.attribute;
        filterValueProp = condensedQuery.split.name;
        splits = ds[0].result.map(function(prop) {
          return {
            prop: prop,
            _interval: interval,
            _filters: andFilters(filters, makeFilter(filterAttribute, prop[filterValueProp]))
          };
        });
        callback(null, splits);
      });
    },
    histogram: function(_arg, callback) {
      var condensedQuery, dataSource, filters, interval, requester;
      requester = _arg.requester, dataSource = _arg.dataSource, interval = _arg.interval, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
      callback("not implemented yet");
      return;
    }
  };

  exports = function(_arg) {
    var aproximate, dataSource, filters, interval, requester, timeAttribute;
    requester = _arg.requester, dataSource = _arg.dataSource, timeAttribute = _arg.timeAttribute, aproximate = _arg.aproximate, interval = _arg.interval, filters = _arg.filters;
    timeAttribute || (timeAttribute = 'time');
    if (aproximate == null) {
      aproximate = true;
    }
    return function(query, callback) {
      var cmdIndex, condensedQuery, queryDruid, rootSegment, segments;
      condensedQuery = driverUtil.condenseQuery(query);
      rootSegment = null;
      segments = [rootSegment];
      queryDruid = function(condensedQuery, done) {
        var QUERY_LIMIT, combinePropName, queryFn, queryFns, queryForSegment, _ref;
        if (condensedQuery.split) {
          switch (condensedQuery.split.bucket) {
            case 'identity':
              if (!((_ref = condensedQuery.combine) != null ? _ref.sort : void 0)) {
                done("must have a sort combine for a split");
                return;
              }
              combinePropName = condensedQuery.combine.sort.prop;
              if (!combinePropName) {
                done("must have a sort prop name");
                return;
              }
              if (findApply(condensedQuery.applies, combinePropName) && aproximate) {
                queryFn = druidQuery.topN;
              } else {
                done('not implemented yet');
                return;
              }
              break;
            case 'time':
              queryFn = druidQuery.timeseries;
              break;
            case 'continuous':
              queryFn = druidQuery.histogram;
              break;
            default:
              done('unsupported query');
              return;
          }
        } else {
          queryFn = druidQuery.all;
        }
        queryForSegment = function(parentSegment, done) {
          queryFn({
            requester: requester,
            dataSource: dataSource,
            interval: parentSegment ? parentSegment._interval : interval,
            filters: parentSegment ? parentSegment._filters : filters,
            condensedQuery: condensedQuery
          }, function(err, splits) {
            if (err) {
              done(err);
              return;
            }
            if (parentSegment) {
              parentSegment.splits = splits;
              driverUtil.cleanSegment(parentSegment);
            } else {
              rootSegment = splits[0];
            }
            done(null, splits);
          });
        };
        QUERY_LIMIT = 10;
        queryFns = async.mapLimit(segments, QUERY_LIMIT, queryForSegment, function(err, results) {
          if (err) {
            done(err);
            return;
          }
          segments = driverUtil.flatten(results);
          done();
        });
      };
      cmdIndex = 0;
      async.whilst(function() {
        return cmdIndex < condensedQuery.length;
      }, function(done) {
        var condenced;
        condenced = condensedQuery[cmdIndex];
        cmdIndex++;
        queryDruid(condenced, done);
      }, function(err) {
        if (err) {
          callback(err);
          return;
        }
        segments.forEach(driverUtil.cleanSegment);
        callback(null, rootSegment);
      });
    };
  };

  if (typeof module === 'undefined') {
    window['druidDriver'] = exports;
  } else {
    module.exports = exports;
  }

}).call(this);
