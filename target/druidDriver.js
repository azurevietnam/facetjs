// Generated by CoffeeScript 1.3.1
(function() {
  var addApplies, andFilters, async, condensedQueryToDruid, driverUtil, exports, findApply, findCountApply, makeFilter, rq, toDruidInterval,
    __slice = [].slice;

  rq = function(module) {
    var moduleParts;
    if (typeof window === 'undefined') {
      return require(module);
    } else {
      moduleParts = module.split('/');
      return window[moduleParts[moduleParts.length - 1]];
    }
  };

  async = rq('async');

  driverUtil = rq('./driverUtil');

  if (typeof exports === 'undefined') {
    exports = {};
  }

  makeFilter = function(attribute, value) {
    return {
      type: 'selector',
      dimension: attribute,
      value: value
    };
  };

  andFilters = function() {
    var filters;
    filters = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    filters = filters.filter(function(filter) {
      return filter != null;
    });
    switch (filters.length) {
      case 0:
        return null;
      case 1:
        return filters[0];
      default:
        return {
          type: 'and',
          fields: filters
        };
    }
  };

  findApply = function(applies, propName) {
    var apply, _i, _len;
    for (_i = 0, _len = applies.length; _i < _len; _i++) {
      apply = applies[_i];
      if (apply.prop === propName) {
        return apply;
      }
    }
  };

  findCountApply = function(applies) {
    var apply, _i, _len;
    for (_i = 0, _len = applies.length; _i < _len; _i++) {
      apply = applies[_i];
      if (apply.aggregate === 'count') {
        return apply;
      }
    }
  };

  toDruidInterval = function(interval) {
    return interval.map(function(d) {
      return d.toISOString().replace('Z', '');
    }).join('/');
  };

  addApplies = function(druidQuery, applies, invertApply) {
    var apply, countPropName, _i, _len;
    countPropName = null;
    druidQuery.aggregations = [];
    for (_i = 0, _len = applies.length; _i < _len; _i++) {
      apply = applies[_i];
      switch (apply.aggregate) {
        case 'count':
          if (apply !== invertApply) {
            countPropName = apply.prop;
            druidQuery.aggregations.push({
              type: "count",
              name: apply.prop
            });
          } else {
            throw new Error("not implemented yet");
          }
          break;
        case 'sum':
          if (apply !== invertApply) {
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.prop,
              fieldName: apply.attribute
            });
          } else {
            throw new Error("not implemented yet");
          }
          break;
        case 'average':
          if (apply !== invertApply) {
            callback("not implemented correctly yet");
            return;
            druidQuery.aggregations.push({
              type: "doubleSum",
              name: apply.prop,
              fieldName: apply.attribute
            });
          } else {
            throw new Error("not implemented yet");
          }
          break;
        case 'min':
          if (apply !== invertApply) {
            druidQuery.aggregations.push({
              type: "min",
              name: apply.prop,
              fieldName: apply.attribute
            });
          } else {
            throw new Error("not implemented yet");
          }
          break;
        case 'max':
          if (apply !== invertApply) {
            druidQuery.aggregations.push({
              type: "max",
              name: apply.prop,
              fieldName: apply.attribute
            });
          } else {
            throw new Error("not implemented yet");
          }
          break;
        case 'unique':
          if (apply === invertApply) {
            throw new Error("not implemented yet");
          } else {
            throw new Error("not implemented yet");
          }
      }
    }
  };

  condensedQueryToDruid = function(_arg, callback) {
    var bucketDuration, combinePropName, condensedQuery, dataSource, druidQuery, filters, interval, invertApply, requester, sort, timePropName, _ref, _ref1, _ref2;
    requester = _arg.requester, dataSource = _arg.dataSource, interval = _arg.interval, filters = _arg.filters, condensedQuery = _arg.condensedQuery;
    if ((interval != null ? interval.length : void 0) !== 2) {
      callback("Must have valid interval [start, end]");
      return;
    }
    if (condensedQuery.applies.length === 0) {
      callback(null, [
        {
          prop: {},
          _interval: interval,
          _filters: filters
        }
      ]);
      return;
    }
    druidQuery = {
      dataSource: dataSource,
      intervals: [toDruidInterval(interval)]
    };
    if (filters) {
      druidQuery.filter = filters;
    }
    invertApply = null;
    if (condensedQuery.split) {
      if (!((_ref = condensedQuery.combine) != null ? _ref.sort : void 0)) {
        callback("must have a sort combine for a split");
        return;
      }
      combinePropName = condensedQuery.combine.sort.prop;
      if (!combinePropName) {
        callback("must have a sort prop name");
        return;
      }
      switch (condensedQuery.split.bucket) {
        case 'identity':
          if (findApply(condensedQuery.applies, combinePropName)) {
            if (!condensedQuery.split.attribute) {
              callback("split must have an attribute");
              return;
            }
            if (!condensedQuery.split.prop) {
              callback("split must have a prop");
              return;
            }
            sort = condensedQuery.combine.sort;
            if ((_ref1 = sort.direction) !== 'ASC' && _ref1 !== 'DESC') {
              callback("direction has to be 'ASC' or 'DESC'");
              return;
            }
            if (sort.direction === 'ASC') {
              invertApply = findApply(condensedQuery.applies, sort.prop);
              if (!invertApply) {
                callback("no apply to invert for bottomN");
                return;
              }
            }
            druidQuery.queryType = "topN";
            druidQuery.granularity = "all";
            druidQuery.dimension = {
              type: 'default',
              dimension: condensedQuery.split.attribute,
              outputName: condensedQuery.split.prop
            };
            druidQuery.threshold = condensedQuery.combine.limit || 10;
            druidQuery.metric = combinePropName;
          } else {
            callback("not supported yet");
            return;
          }
          break;
        case 'time':
          druidQuery.queryType = "timeseries";
          timePropName = condensedQuery.split.prop;
          if (combinePropName !== timePropName) {
            callback("Must sort on the time prop for now (temp)");
          }
          return;
          bucketDuration = condensedQuery.split.duration;
          if (!bucketDuration) {
            callback("Must have duration for time bucket");
            return;
          }
          if ((_ref2 = !bucketDuration) === 'second' || _ref2 === 'minute' || _ref2 === 'hour' || _ref2 === 'day') {
            callback("Unsupported duration '" + bucketDuration + "' in time bucket");
            return;
          }
          druidQuery.granularity = bucketDuration;
          break;
        default:
          callback("Unsupported bucketing '" + condensedQuery.split.bucket + "' in split");
          return;
      }
    } else {
      druidQuery.queryType = "timeseries";
      druidQuery.granularity = "all";
    }
    if (condensedQuery.applies.length > 0) {
      try {
        addApplies(druidQuery, condensedQuery.applies, invertApply);
      } catch (e) {
        callback(e);
        return;
      }
    }
    requester(druidQuery, function(err, ds) {
      var filterAttribute, filterValueProp, splits;
      if (err) {
        callback(err);
        return;
      }
      if (condensedQuery.split) {
        switch (condensedQuery.split.bucket) {
          case 'identity':
            if (ds.length !== 1) {
              callback("something went wrong");
              return;
            }
            filterAttribute = condensedQuery.split.attribute;
            filterValueProp = condensedQuery.split.prop;
            splits = ds[0].result.map(function(prop) {
              return {
                prop: prop,
                _interval: interval,
                _filters: andFilters(filters, makeFilter(filterAttribute, prop[filterValueProp]))
              };
            });
            break;
          case 'time':
            splits = [
              {
                prop: {
                  "not": "implemented yet"
                },
                _interval: interval,
                _filters: filters
              }
            ];
            break;
          default:
            callback("Unsupported bucketing '" + condensedQuery.split.bucket + "' in split post process");
            return;
        }
      } else {
        if (ds.length !== 1) {
          callback("something went wrong");
          return;
        }
        splits = [
          {
            prop: ds[0].result,
            _interval: interval,
            _filters: filters
          }
        ];
      }
      callback(null, splits);
    });
  };

  exports = function(_arg) {
    var dataSource, filters, interval, requester, timeAttribute;
    requester = _arg.requester, dataSource = _arg.dataSource, timeAttribute = _arg.timeAttribute, interval = _arg.interval, filters = _arg.filters;
    timeAttribute || (timeAttribute = 'time');
    return function(query, callback) {
      var cmdIndex, condensedQuery, queryDruid, rootSegment, segments;
      condensedQuery = driverUtil.condenseQuery(query);
      rootSegment = null;
      segments = [rootSegment];
      queryDruid = function(condensed, done) {
        var QUERY_LIMIT, queryFns;
        QUERY_LIMIT = 10;
        queryFns = async.mapLimit(segments, QUERY_LIMIT, function(parentSegment, done) {
          return condensedQueryToDruid({
            requester: requester,
            dataSource: dataSource,
            interval: parentSegment ? parentSegment._interval : interval,
            filters: parentSegment ? parentSegment._filters : filters,
            condensedQuery: condensed
          }, function(err, splits) {
            if (err) {
              done(err);
              return;
            }
            if (parentSegment) {
              parentSegment.splits = splits;
              driverUtil.cleanSegment(parentSegment);
            } else {
              rootSegment = splits[0];
            }
            done(null, splits);
          });
        }, function(err, results) {
          if (err) {
            done(err);
            return;
          }
          segments = driverUtil.flatten(results);
          done();
        });
      };
      cmdIndex = 0;
      async.whilst(function() {
        return cmdIndex < condensedQuery.length;
      }, function(done) {
        var condenced;
        condenced = condensedQuery[cmdIndex];
        cmdIndex++;
        queryDruid(condenced, done);
      }, function(err) {
        if (err) {
          callback(err);
          return;
        }
        segments.forEach(driverUtil.cleanSegment);
        callback(null, rootSegment);
      });
    };
  };

  if (typeof module === 'undefined') {
    window['druidDriver'] = exports;
  } else {
    module.exports = exports;
  }

}).call(this);
